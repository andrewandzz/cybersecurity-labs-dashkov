<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Email-шифратор</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <style>
    body { background:#f8f9fa; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; }
    textarea { resize: vertical; }
    .box { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body>
<div class="container py-4">
  <h1 class="text-center mb-4">Email-шифратор</h1>

  <div class="row g-3">
    <div class="col-lg-6">
      <div class="card shadow-sm h-100">
        <div class="card-body">
          <h5 class="mb-3">Бік відправника</h5>

          <div class="mb-3">
            <label class="form-label">Email відправника</label>
            <input id="senderEmail" class="form-control" placeholder="john.doe@gmail.com" />
          </div>

          <div class="mb-3">
            <label class="form-label">Персональний секрет</label>
            <input id="senderSecret" class="form-control" placeholder="JohnDoe" />
          </div>

          <div class="mb-3">
            <label class="form-label">Email отримувача (для спільного ключа)</label>
            <input id="receiverEmailForSender" class="form-control" placeholder="foo.bar@gmail.com" />
          </div>

          <div class="mb-3">
            <label class="form-label">Персональний секрет отримувача (відомий відправнику для демо)</label>
            <input id="receiverSecretForSender" class="form-control" placeholder="FooBar" />
            <div class="form-text">Для демонстрації обидві сторони знають потрібні дані для однакового ключа.</div>
          </div>

          <div class="mb-3">
            <label class="form-label">Повідомлення</label>
            <textarea id="plainText" class="form-control" rows="3"
              placeholder="Перетелефонуй мені о 18:00"></textarea>
          </div>

          <div class="d-flex gap-2 flex-wrap">
            <button class="btn btn-primary" id="encryptBtn">Зашифрувати</button>
          </div>

          <div id="senderStatus" class="alert d-none mt-3 mb-0"></div>

          <hr class="my-3" />

          <label class="form-label">Зашифровані дані (Base64)</label>
          <textarea id="cipherText" class="form-control mono" rows="5" readonly></textarea>
          <div class="form-text">Це те, що “відправляється” електронною поштою.</div>

          <button class="btn btn-success mt-2 d-none" id="copyCipherBtn">Скопіювати шифртекст</button>
        </div>
      </div>
    </div>

    <div class="col-lg-6">
      <div class="card shadow-sm h-100">
        <div class="card-body">
          <h5 class="mb-3">Бік отримувача</h5>

          <div class="mb-3">
            <label class="form-label">Email отримувача</label>
            <input id="receiverEmail" class="form-control" placeholder="foo.bar@gmail.com" />
          </div>

          <div class="mb-3">
            <label class="form-label">Персональний секрет отримувача</label>
            <input id="receiverSecret" class="form-control" placeholder="FooBar" />
          </div>

          <div class="mb-3">
            <label class="form-label">Email відправника (для спільного ключа)</label>
            <input id="senderEmailForReceiver" class="form-control" placeholder="john.doe@gmail.com" />
          </div>

          <div class="mb-3">
            <label class="form-label">Персональний секрет відправника (відомий отримувачу для демо)</label>
            <input id="senderSecretForReceiver" class="form-control" placeholder="JohnDoe" />
          </div>

          <div class="mb-3">
            <label class="form-label">Отриманий шифртекст (Base64)</label>
            <textarea id="receivedCipher" class="form-control mono" rows="5"
              placeholder="Вставте сюди шифртекст..."></textarea>
          </div>

          <button class="btn btn-primary" id="decryptBtn">Розшифрувати</button>

          <hr class="my-3" />

          <div id="receiverStatus" class="alert d-none mt-3"></div>

          <label class="form-label mt-2">Розшифроване повідомлення</label>
          <div id="decryptedOut" class="border rounded p-2 bg-white box">—</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const $ = (id) => document.getElementById(id);

  $("copyCipherBtn").addEventListener("click", async () => {
    await navigator.clipboard.writeText($("cipherText").value);
    showAlert("senderStatus", "success", "Шифртекст скопійовано");
  });

  $("encryptBtn").addEventListener("click", async () => {
    hideAlert("senderStatus");

    const senderEmail = $("senderEmail").value.trim();
    const senderSecret = $("senderSecret").value.trim();
    const receiverEmail = $("receiverEmailForSender").value.trim();
    const receiverSecret = $("receiverSecretForSender").value.trim();
    const message = $("plainText").value;

    if (!senderEmail || !senderSecret || !receiverEmail || !receiverSecret || !message) {
      showAlert("senderStatus", "danger", "Заповніть усі поля у блоці Відправника.");
      return;
    }

    try {
      const key = await deriveSharedKey(senderEmail, senderSecret, receiverEmail, receiverSecret);

      const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV для AES-GCM
      const data = new TextEncoder().encode(message);

      const cipherBuf = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );

      // Пакуємо: iv + ciphertext -> Base64
      const packed = concatBytes(iv, new Uint8Array(cipherBuf));
      const b64 = bytesToBase64(packed);

      $("cipherText").value = b64;
      $("copyCipherBtn").classList.remove("d-none");
      showAlert("senderStatus", "success", "Повідомлення зашифровано Тепер надішліть Base64-рядок отримувачу.");
    } catch (e) {
      showAlert("senderStatus", "danger", "Помилка шифрування: " + (e?.message || e));
    }
  });

  $("decryptBtn").addEventListener("click", async () => {
    hideAlert("receiverStatus");

    const receiverEmail = $("receiverEmail").value.trim();
    const receiverSecret = $("receiverSecret").value.trim();
    const senderEmail = $("senderEmailForReceiver").value.trim();
    const senderSecret = $("senderSecretForReceiver").value.trim();
    const received = $("receivedCipher").value.trim();

    if (!receiverEmail || !receiverSecret || !senderEmail || !senderSecret || !received) {
      showAlert("receiverStatus", "danger", "Заповніть усі поля у блоці Отримувача.");
      return;
    }

    try {
      const key = await deriveSharedKey(senderEmail, senderSecret, receiverEmail, receiverSecret);

      const packed = base64ToBytes(received);
      if (packed.length < 13) {
        showAlert("receiverStatus", "danger", "Шифртекст занадто короткий/пошкоджений.");
        return;
      }

      const iv = packed.slice(0, 12);
      const cipher = packed.slice(12);

      const plainBuf = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        cipher
      );

      const text = new TextDecoder().decode(plainBuf);
      $("decryptedOut").textContent = text;
      showAlert("receiverStatus", "success", "Повідомлення успішно розшифровано");
    } catch (e) {
      $("decryptedOut").textContent = "—";
      showAlert("receiverStatus", "danger",
        "Не вдалося розшифрувати (ймовірно, ключі/дані не збігаються або шифртекст пошкоджений)."
      );
    }
  });

  // Робимо спільний матеріал ключа з двох "ідентифікаторів" і СОРТУЄМО,
  // щоб і відправник, і отримувач отримали однаковий результат незалежно від порядку.
  async function deriveSharedKey(senderEmail, senderSecret, receiverEmail, receiverSecret) {
    const a = normalize(senderEmail) + "|" + senderSecret.trim();
    const b = normalize(receiverEmail) + "|" + receiverSecret.trim();
    const pair = [a, b].sort().join("||"); // нормалізація порядку

    // SHA-256 -> 32 bytes -> AES-256 key
    const hash = await sha256Bytes(new TextEncoder().encode(pair));
    return crypto.subtle.importKey(
      "raw",
      hash,
      { name: "AES-GCM" },
      false,
      ["encrypt", "decrypt"]
    );
  }

  function normalize(s) {
    return (s || "").trim().toLowerCase();
  }

  async function sha256Bytes(data) {
    const digest = await crypto.subtle.digest("SHA-256", data);
    return new Uint8Array(digest);
  }

  function bytesToBase64(bytes) {
    let bin = "";
    for (const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }

  function base64ToBytes(b64) {
    const bin = atob(b64);
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
    return out;
  }

  function concatBytes(a, b) {
    const out = new Uint8Array(a.length + b.length);
    out.set(a, 0);
    out.set(b, a.length);
    return out;
  }

  function showAlert(id, type, text) {
    const el = $(id);
    el.className = "alert alert-" + type + " mt-3 mb-0";
    el.textContent = text;
    el.classList.remove("d-none");
  }
  function hideAlert(id) {
    const el = $(id);
    el.classList.add("d-none");
    el.textContent = "";
  }
</script>
</body>
</html>
